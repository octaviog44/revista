'use strict';Object.defineProperty(exports, "__esModule", { value: true });exports.captureDependency = captureDependency;exports.

































captureDependencyWithSpecifiers = captureDependencyWithSpecifiers;function captureDependency(_ref, isOnlyImportingTypes, remotePathResolver, exportMap, context, thunkFor) {var source = _ref.source;var importedSpecifiers = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new Set();if (source == null) {return null;}var p = remotePathResolver.resolve(source.value);if (p == null) {return null;}var declarationMetadata = { // capturing actual node reference holds full AST in memory!
    source: { value: source.value, loc: source.loc }, isOnlyImportingTypes: isOnlyImportingTypes, importedSpecifiers: importedSpecifiers };var existing = exportMap.imports.get(p);if (existing != null) {existing.declarations.add(declarationMetadata);return existing.getter;}var getter = thunkFor(p, context);exportMap.imports.set(p, { getter: getter, declarations: new Set([declarationMetadata]) });return getter;}var supportedImportTypes = new Set(['ImportDefaultSpecifier', 'ImportNamespaceSpecifier']);function captureDependencyWithSpecifiers(n,
remotePathResolver,
exportMap,
context,
thunkFor)
{
  // import type { Foo } (TS and Flow); import typeof { Foo } (Flow)
  var declarationIsType = n.importKind === 'type' || n.importKind === 'typeof';
  // import './foo' or import {} from './foo' (both 0 specifiers) is a side effect and
  // shouldn't be considered to be just importing types
  var specifiersOnlyImportingTypes = n.specifiers.length > 0;
  var importedSpecifiers = new Set();
  n.specifiers.forEach(function (specifier) {
    if (specifier.type === 'ImportSpecifier') {
      importedSpecifiers.add(specifier.imported.name || specifier.imported.value);
    } else if (supportedImportTypes.has(specifier.type)) {
      importedSpecifiers.add(specifier.type);
    }

    // import { type Foo } (Flow); import { typeof Foo } (Flow)
    specifiersOnlyImportingTypes = specifiersOnlyImportingTypes && (
    specifier.importKind === 'type' || specifier.importKind === 'typeof');
  });
  captureDependency(n, declarationIsType || specifiersOnlyImportingTypes, remotePathResolver, exportMap, context, thunkFor, importedSpecifiers);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9leHBvcnRNYXAvY2FwdHVyZURlcGVuZGVuY3kuanMiXSwibmFtZXMiOlsiY2FwdHVyZURlcGVuZGVuY3kiLCJjYXB0dXJlRGVwZW5kZW5jeVdpdGhTcGVjaWZpZXJzIiwiaXNPbmx5SW1wb3J0aW5nVHlwZXMiLCJyZW1vdGVQYXRoUmVzb2x2ZXIiLCJleHBvcnRNYXAiLCJjb250ZXh0IiwidGh1bmtGb3IiLCJzb3VyY2UiLCJpbXBvcnRlZFNwZWNpZmllcnMiLCJTZXQiLCJwIiwicmVzb2x2ZSIsInZhbHVlIiwiZGVjbGFyYXRpb25NZXRhZGF0YSIsImxvYyIsImV4aXN0aW5nIiwiaW1wb3J0cyIsImdldCIsImRlY2xhcmF0aW9ucyIsImFkZCIsImdldHRlciIsInNldCIsInN1cHBvcnRlZEltcG9ydFR5cGVzIiwibiIsImRlY2xhcmF0aW9uSXNUeXBlIiwiaW1wb3J0S2luZCIsInNwZWNpZmllcnNPbmx5SW1wb3J0aW5nVHlwZXMiLCJzcGVjaWZpZXJzIiwibGVuZ3RoIiwiZm9yRWFjaCIsInNwZWNpZmllciIsInR5cGUiLCJpbXBvcnRlZCIsIm5hbWUiLCJoYXMiXSwibWFwcGluZ3MiOiJtRkFBZ0JBLGlCLEdBQUFBLGlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBQywrQixHQUFBQSwrQixDQWxDVCxTQUFTRCxpQkFBVCxPQUVMRSxvQkFGSyxFQUdMQyxrQkFISyxFQUlMQyxTQUpLLEVBS0xDLE9BTEssRUFNTEMsUUFOSyxFQVFMLEtBUEVDLE1BT0YsUUFQRUEsTUFPRixLQURBQyxrQkFDQSx1RUFEcUIsSUFBSUMsR0FBSixFQUNyQixDQUNBLElBQUlGLFVBQVUsSUFBZCxFQUFvQixDQUFFLE9BQU8sSUFBUCxDQUFjLENBRXBDLElBQU1HLElBQUlQLG1CQUFtQlEsT0FBbkIsQ0FBMkJKLE9BQU9LLEtBQWxDLENBQVYsQ0FDQSxJQUFJRixLQUFLLElBQVQsRUFBZSxDQUFFLE9BQU8sSUFBUCxDQUFjLENBRS9CLElBQU1HLHNCQU